package com.pwootage.metroidprime.dump

import java.io._
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Path, Paths}
import java.util
import java.util.Base64
import java.util.zip.{Deflater, DeflaterOutputStream, InflaterOutputStream}

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.node.ObjectNode
import com.google.diff.diff_match_patch
import com.pwootage.metroidprime.formats.common.PrimeVersion
import com.pwootage.metroidprime.formats.io.PrimeDataFile
import com.pwootage.metroidprime.formats.iso.{FST, FileDirectory, GCIsoHeaders}
import com.pwootage.metroidprime.formats.mrea.MREA
import com.pwootage.metroidprime.formats.pak.{PAKFile, Resource}
import com.pwootage.metroidprime.utils._
import org.anarres.lzo._

import scala.collection.mutable
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._
import scala.util.Random

class Differ(quieter: Boolean) {
  var patches = Seq[PatchAction]()

  def dif(file1Path: String, file2Path: String, destDir: String): Unit = {
    Logger.info("Things to note:")
    Logger.info("This diff won't handle:")
    Logger.info("- Added/removed FST files (modified is fine):")
    Logger.info("- A couple edge cases (check for warnings (yellow) in your output and file an issue if there are none)")

    val file1 = Paths.get(file1Path)
    val file2 = Paths.get(file2Path)
    val dest = Paths.get(destDir)
    Files.createDirectories(dest)

    val file1raf = new RandomAccessFile(file1.toFile, "r")
    val file2raf = new RandomAccessFile(file2.toFile, "r")

    Logger.progress("Reading ISO header information...")

    val header1 = new GCIsoHeaders
    val header2 = new GCIsoHeaders
    file1raf.seek(0)
    PrimeDataFile(Some(file1raf), Some(file1raf)).read(header1)
    file2raf.seek(0)
    PrimeDataFile(Some(file2raf), Some(file2raf)).read(header2)

    val gameID1 = DataTypeConversion.intContainingCharsAsStr(header1.discHeader.gameCode) + DataTypeConversion.intContainingCharsAsStr(header1.discHeader.makerCode)
    val gameID2 = DataTypeConversion.intContainingCharsAsStr(header1.discHeader.gameCode) + DataTypeConversion.intContainingCharsAsStr(header1.discHeader.makerCode)

    if (gameID1 != gameID2) {
      Logger.error(s"Two different games, can't diff ($gameID1, $gameID2)")
    }

    Logger.info(s"Found game ID $gameID1 version ${header1.discHeader.version} (Internal name: ${header1.discHeader.name})")

    val version = if (gameID1 == "GM8E01" || gameID1 == "GM8P01") {
      Some(PrimeVersion.PRIME_1)
    } else if (gameID2 == "G2ME01") {
      Some(PrimeVersion.PRIME_2)
    } else {
      None
    }

    if (version.isEmpty) {
      Logger.error("Unknown game; can't diff")
      System.exit(1)
    }

    Logger.progress("Parsing file structure....")
    val fst1 = new FST
    file1raf.seek(header1.discHeader.fstOffset)
    PrimeDataFile(Some(file1raf), Some(file1raf)).read(fst1)
    val fst2 = new FST
    file2raf.seek(header2.discHeader.fstOffset)
    PrimeDataFile(Some(file2raf), Some(file2raf)).read(fst2)

    Logger.info(s"Found ${fst1.rootDirectoryEntry.recursivelyCalculateEntryCount + 1} files and folders")
    Logger.info(s"Found ${fst2.rootDirectoryEntry.recursivelyCalculateEntryCount + 1} files and folders")

    recursivelyDiffFiles(version, file1raf, file2raf, Some(fst1.rootDirectoryEntry), Some(fst2.rootDirectoryEntry), dest)

    file1raf.close()
    file2raf.close()

    val patchfile = Patchfile("Auto-generated patchfile", patches, Some("Generated by prime-patcher"))
    val destPatchfile = dest.resolve("patch.json")
    Logger.info(s"Writing $destPatchfile")
    Files.write(destPatchfile, PrimeJacksonMapper.mapper.writerWithDefaultPrettyPrinter().writeValueAsBytes(patchfile))

    Logger.success("Done")
  }

  private def recursivelyDiffFiles(version: Option[PrimeVersion],
                                   file1: RandomAccessFile,
                                   file2: RandomAccessFile,
                                   dir1Opt: Option[FileDirectory],
                                   dir2Opt: Option[FileDirectory],
                                   dest: Path): Unit = {
    if (dir1Opt.isDefined && dir2Opt.isEmpty) {
      Logger.warning(s"Deleted FST directory ${dir1Opt.get.name}, not currently able to patch this (TODO)")
      //      val deletePatch = new Patchfile(s"Delete directory ${dir1.get.name}", DeleteFSTDirectoryPatch(dir1.get.name, ))
      return
    } else if (dir1Opt.isEmpty && dir2Opt.isDefined) {
      Logger.warning(s"Created FST directory ${dir1Opt.get.name}, not currently able to patch this (TODO)")
      return
    }

    val dir1 = dir1Opt.get
    val dir2 = dir2Opt.get

    for (dir1Child <- dir1.fileChildren) {
      val dir2ChildOpt = dir2.fileChildren.find(_.name == dir1Child.name)
      if (dir2ChildOpt.isEmpty) {
        Logger.warning(s"Deleted FST file ${dir1Child.name}, not currently able to patch this (TODO)")
        //TODO: also need to do created files
      } else {
        val dir2Child = dir2ChildOpt.get
        val len = dir1Child.length
        if (dir1Child.name.toLowerCase.endsWith(".pak")) {
          Logger.progressResetLine(s"Diffing ${dir1Child.name} as a PAK")
          file1.seek(dir1Child.offset)
          file2.seek(dir2Child.offset)
          difPaksFromRAFFromCurrentOffset(version.get, dir1Child.name, file1, file2, dest)
        } else {
          Logger.progressResetLine(s"Diffing ${dir1Child.name}")

          file1.seek(dir1Child.offset)
          file2.seek(dir2Child.offset)
          val diffLoc = PrimeDiffUtils.firstDifference(new RandomAccessFileInputStream(file1), new RandomAccessFileInputStream(file2), dir1Child.length)
          if (diffLoc > 0 || dir1Child.length != dir2Child.length) {
            Logger.progressResetLine(s"Differing FST file ${dir1Child.name}")

            val bout1 = new ByteArrayOutputStream()
            val bout2 = new ByteArrayOutputStream()

            file1.seek(dir1Child.offset)
            file2.seek(dir2Child.offset)
            copyBytes(new RandomAccessFileInputStream(file1), dir1Child.length, bout1)
            copyBytes(new RandomAccessFileInputStream(file2), dir2Child.length, bout2)

            patches +:= createBinaryDiffForBytes(version.get, dir1Child.name, dest, bout1.toByteArray, bout2.toByteArray)
          }
        }
      }
    }

    for (dir1child <- dir1.directoryChildren) {
      val dir2child = dir2.directoryChildren.find(_.name == dir1child.name)
      recursivelyDiffFiles(version, file1, file2, Some(dir1child), dir2child, dest)
    }
  }

  private def copyBytes(in: InputStream, len: Int, out: OutputStream): Unit = {
    val buff = new Array[Byte](16 * 1026) //16k blocks
    var totalRead = 0
    while (totalRead < len) {
      val toRead = Math.min(buff.length, len - totalRead)
      val read = in.read(buff, 0, toRead)
      if (read < 0) {
        throw new IOException("Attempt to read too many bytes")
      }
      out.write(buff, 0, read)
      totalRead += read
    }
  }

  private def difPaksFromRAFFromCurrentOffset(primeVersion: PrimeVersion, pakName: String, file1: RandomAccessFile, file2: RandomAccessFile, dest: Path) = {
    val pak1start = file1.getFilePointer
    val pak2start = file2.getFilePointer

    val pak1 = new PAKFile(primeVersion)
    val pak2 = new PAKFile(primeVersion)
    new PrimeDataFile(Some(file1), None).read(pak1)
    new PrimeDataFile(Some(file2), None).read(pak2)

    val pak1FileList = pak1.resources.map(_.idStr).mkString("\n")
    val pak2FileList = pak2.resources.map(_.idStr).mkString("\n")

    val resourcesInPak1ById = Map(pak1.resources.map(res => (res.idLong, res)): _*)
    val resourcesInPak2ById = Map(pak2.resources.map(res => (res.idLong, res)): _*)

    val differ = new diff_match_patch

    val pakDiff = differ.diff_main(pak1FileList, pak2FileList)
    differ.diff_cleanupEfficiency(pakDiff)
    val pakPatch = differ.patch_make(pakDiff)

    if (pakPatch.nonEmpty) {
      Logger.info(s"$pakName has modified file list")
      val patch = PakfileResourceListPatch(
        pakName,
        differ.patch_toText(pakPatch)
      )
      patch.description = Some(s"Modify $pakName's file list")
      patches +:= patch

      //Figure out which files were added, so we can copy them into the patch directory
      val newFiles = pak2.resources.map(_.idLong).toSet -- pak1.resources.map(_.idLong)

      for (file <- newFiles) {
        val res = resourcesInPak2ById(file)
        if (Files.exists(dest.resolve(res.idStr))) {
          Logger.progressResetLine(s"Already copied ${res.idStr}")
        } else {
          Logger.progressResetLine(s"Copying out ${res.idStr}")
          val out = Files.newOutputStream(dest.resolve(res.idStr))
          readResourceToStream(primeVersion, pak2start.toInt, file2, res, out)
          out.close()
        }
      }
    }

    for (resource2 <- pak2.resources) {
      val resource1Option = resourcesInPak1ById.get(resource2.idLong)
      if (resource1Option.isDefined) {

        val resource1 = resource1Option.get
        file1.seek(resource1.offset + pak1start)
        file2.seek(resource2.offset + pak2start)
        if (resource1.size != resource2.size || PrimeDiffUtils.firstDifference(new RandomAccessFileInputStream(file1), new RandomAccessFileInputStream(file2), resource1.size) >= 0) {
          //Files are different

          if (resource2.idStr.endsWith(".MREA")) {
            val mreaName = resource2.idStr
            val mrea1 = new MREA
            val mrea2 = new MREA

            val bout1 = new ByteArrayOutputStream()
            val bout2 = new ByteArrayOutputStream()
            readResourceToStream(primeVersion, pak1start.toInt, file1, resource1, bout1)
            readResourceToStream(primeVersion, pak2start.toInt, file2, resource2, bout2)

            mrea1.read(bout1.toByteArray)
            mrea2.read(bout2.toByteArray)

            val scly1 = mrea1.parseSCLY
            val scly2 = mrea2.parseSCLY

            val scly1Objects = scly1.layers.flatMap(_.objects)
            val scly2Objects = scly2.layers.flatMap(_.objects)

            val scly1ObjectsById = Map(scly1Objects.map(obj => (obj.id, obj)):_*)
            val scly2ObjectsById = Map(scly2Objects.map(obj => (obj.id, obj)):_*)

            val removedIds = scly1Objects.map(_.id).toSet -- scly2Objects.map(_.id)
            for (id <- removedIds) {
              val obj = scly1ObjectsById(id)
              val patch = ScriptObjectPatch(mreaName, obj.typeString, id)
              patch.remove = Some(true)
              patch.description = Some(s"Remove script object id $id")
              patches +:= patch
            }

            val adddedIds = scly2Objects.map(_.id).toSet -- scly1Objects.map(_.id)
            for (id <- adddedIds) {
              val obj = scly2ObjectsById(id)
              val patchJson = PrimeJacksonMapper.mapper.createObjectNode()
              for (prop <- obj.toTemplate.properties) {
                patchJson.set(prop.ID, prop.valueAsJson)
              }
              val patch = ScriptObjectPatch(mreaName, obj.typeString, id)
              patch.layer = Some(scly2.layers.indexWhere(_.objects.exists(_.id == id)))
              patch.add = Some(true)
              patch.objectPatch = Some(patchJson)
              patch.description = Some(s"Add script object id $id (${obj.typeString})")
              patches +:= patch
            }

            val modifiedIds = scly2Objects.map(_.id).toSet -- adddedIds
            for (id <- modifiedIds) {
              val obj1 = scly1ObjectsById(id)
              val obj2 = scly2ObjectsById(id)

              if (PrimeDiffUtils.firstDifference(obj1.binaryData, obj2.binaryData) >= 0) {
                val patchJson1 = PrimeJacksonMapper.mapper.createObjectNode()
                val patchJson2 = PrimeJacksonMapper.mapper.createObjectNode()
                for (prop <- obj1.toTemplate.properties) {
                  patchJson1.set(prop.ID, prop.valueAsJson)
                }
                for (prop <- obj2.toTemplate.properties) {
                  patchJson2.set(prop.ID, prop.valueAsJson)
                }

                val realJson = PrimeDiffUtils.recursiveJsonDiff(patchJson1, patchJson2)
                if (realJson.size() > 0) {
                  val patch = ScriptObjectPatch(mreaName, obj2.typeString, id)
                  patch.objectPatch = Some(realJson)
                  patch.description = Some(s"Patch script object id $id (${obj2.typeString})")
                  patches +:= patch
                }
              }
            }

          } else {
            //Binary diff
            val bout1 = new ByteArrayOutputStream()
            val bout2 = new ByteArrayOutputStream()

            readResourceToStream(primeVersion, pak1start.toInt, file1, resource1, bout1)
            readResourceToStream(primeVersion, pak2start.toInt, file2, resource2, bout2)

            val arr1 = bout1.toByteArray
            val arr2 = bout2.toByteArray
            if (PrimeDiffUtils.firstDifference(arr1, arr2) >= 0) { //Make sure it wasn't just a change in compression
              patches +:= createBinaryDiffForBytes(primeVersion, resource2.idStr, dest, arr1, arr2)
            }
          }
        }
      }
      //Done with resource
    }
  }

  def createBinaryDiffForBytes(primeVersion: PrimeVersion, name:String, dest: Path, bytes1: Array[Byte], bytes2: Array[Byte]): PatchAction = {
    val b641 = Base64.getEncoder.encodeToString(bytes1)
    val b642 = Base64.getEncoder.encodeToString(bytes2)

    val differ = new diff_match_patch

    val resourceDiff = differ.diff_main(b641, b642)
    differ.diff_cleanupEfficiency(resourceDiff)
    val resourcePatch = differ.patch_make(resourceDiff)
    val resourcePatchString = differ.patch_toText(resourcePatch)
    val patch = if (resourcePatchString.length < bytes2.length) {
      // Patch is smaller
      val p = Base64BinaryDiffPatch(name, resourcePatchString)
      p.description = Some(s"Patch $name")
      p
    } else {
      //Just include the regular file, for the diff is too large
      if (Files.exists(dest.resolve(name))) {
        Logger.progressResetLine(s"Already copied $name")
      } else {
        Logger.progressResetLine(s"Copying out $name")
        Files.write(dest.resolve(name), bytes2)
      }

      val p = ReplaceFilePatch(name, name)
      p.description = Some(s"Replace $name")
      p
    }
    patch
  }

  def readResourceToStream(primeVersion: PrimeVersion, srcPakStart: Int, srcRaf: RandomAccessFile, resource: Resource, byteOut: OutputStream): Unit = {
    srcRaf.seek(resource.offset + srcPakStart)
    if (resource.compressed) {
      val decompressedSize = srcRaf.readInt()

      if (primeVersion == PrimeVersion.PRIME_1) {
        val resourceStart = srcRaf.getFilePointer

        val decompressedOut = new InflaterOutputStream(byteOut)
        copyBytes(new RandomAccessFileInputStream(srcRaf), resource.size - 4, decompressedOut)
        decompressedOut.flush()
        val resourceEnd = srcRaf.getFilePointer
        val bytesRead = resourceEnd - resourceStart
        if (bytesRead != resource.size - 4) {
          throw new IOException("Read incorrect number of bytes from original file")
        }
      } else if (primeVersion == PrimeVersion.PRIME_2) {
        var decompressedSoFar = 0
        while (decompressedSoFar < decompressedSize) {
          //Input
          val inBytes = new Array[Byte](srcRaf.readUnsignedShort())
          srcRaf.readFully(inBytes)
          val toRead = Math.min(0x4000, decompressedSize - decompressedSoFar)
          val outBytes = new Array[Byte](toRead)

          //Decompress/verify
          val decompressor = LzoLibrary.getInstance().newDecompressor(LzoAlgorithm.LZO1X, LzoConstraint.COMPRESSION)
          val outLen = new lzo_uintp
          val code = decompressor.decompress(inBytes, 0, inBytes.length, outBytes, 0, outLen)
          if (code != LzoTransformer.LZO_E_OK) {
            throw new IOException(decompressor.toErrorString(code))
          }
          if (outLen.value != toRead) {
            throw new IOException(s"Read incorrect number of bytes: $outLen")
          }

          //Output
          byteOut.write(outBytes)
          decompressedSoFar += toRead
        }
        //Done decompressing
      } else {
        throw new Error("I did something wrong D:")
      }
    } else {
      copyBytes(new RandomAccessFileInputStream(srcRaf), resource.size, byteOut)
    }
  }
}